import { __rest } from 'tslib';
import React from 'react';
import { matchPath, Redirect, Route, withRouter, BrowserRouter } from 'react-router-dom';
import { IonLifeCycleContext, DefaultIonLifeCycleContext, NavContext } from '@ionic/react';

const generateUniqueId = () => {
    const charPool = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const charArray = [];
    for (let i = 0; i < 10; i++) {
        charArray.push(charPool[Math.floor(Math.random() * charPool.length)]);
    }
    return charArray.join('');
};

class ViewInternal extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            ref: null
        };
    }
    componentDidMount() {
        const { forwardedRef } = this.props;
        this.setState({ ref: forwardedRef });
        if (forwardedRef && forwardedRef.current) {
            forwardedRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    componentWillUnmount() {
        const { forwardedRef } = this.props;
        if (forwardedRef && forwardedRef.current) {
            forwardedRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    ionViewWillEnterHandler() {
        this.context.ionViewWillEnter();
    }
    ionViewDidEnterHandler() {
        this.context.ionViewDidEnter();
    }
    ionViewWillLeaveHandler() {
        this.context.ionViewWillLeave();
    }
    ionViewDidLeaveHandler() {
        this.context.ionViewDidLeave();
    }
    render() {
        const _a = this.props, { className, children, forwardedRef } = _a, rest = __rest(_a, ["className", "children", "forwardedRef"]);
        const { ref } = this.state;
        return (React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, rest), ref && children));
    }
    static get contextType() {
        return IonLifeCycleContext;
    }
}
function forwardRef(props, ref) {
    return React.createElement(ViewInternal, Object.assign({ forwardedRef: ref }, props));
}
forwardRef.displayName = 'View';
const View = /*@__PURE__*/ React.forwardRef(forwardRef);

const RouteManagerContext = /*@__PURE__*/ React.createContext({
    viewStacks: {},
    hideView: () => { navContextNotFoundError(); },
    setupIonRouter: () => { navContextNotFoundError(); },
    removeViewStack: () => { navContextNotFoundError(); },
    renderChild: () => { navContextNotFoundError(); },
    transitionView: () => { navContextNotFoundError(); }
});
function navContextNotFoundError() {
    console.error('IonReactRouter not found, did you add it to the app?');
}

class ViewItemManager extends React.Component {
    constructor(props) {
        super(props);
        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
        this._isMounted = false;
        this.state = {
            show: true
        };
        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
            if (!this.props.mount) {
                if (this._isMounted) {
                    this.setState({
                        show: false
                    }, () => {
                        this.context.hideView(this.props.id);
                    });
                }
            }
        });
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
    }
    render() {
        const { show } = this.state;
        return (React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));
    }
    static get contextType() {
        return RouteManagerContext;
    }
}

class ViewManager extends React.Component {
    constructor(props) {
        super(props);
        this.containerEl = React.createRef();
        this.id = this.props.id || generateUniqueId();
    }
    componentDidMount() {
        this.context.setupIonRouter(this.id, this.props.children, this.containerEl.current);
    }
    componentWillUnmount() {
        this.context.removeViewStack(this.id);
    }
    render() {
        const context = this.context;
        const viewStack = context.viewStacks[this.id];
        const activeId = viewStack ? viewStack.activeId : '';
        const views = (viewStack || { views: [] }).views.filter(x => x.show);
        return (React.createElement("ion-router-outlet", { "data-id": this.id, ref: this.containerEl }, views.map((item) => {
            let props = {};
            if (item.id === activeId) {
                props = {
                    'className': ' ion-page-invisible'
                };
            }
            return (React.createElement(ViewItemManager, { id: item.id, key: item.key, mount: item.mount },
                React.createElement(View, Object.assign({ ref: item.ref }, props), this.context.renderChild(item))));
        })));
    }
    static get contextType() {
        return RouteManagerContext;
    }
}

class NavManager extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            goBack: this.goBack.bind(this),
            hasIonicRouter: () => true,
            getHistory: this.getHistory.bind(this),
            getLocation: this.getLocation.bind(this),
            navigate: this.navigate.bind(this),
            getViewManager: this.getViewManager.bind(this),
            currentPath: this.props.location.pathname
        };
        this.listenUnregisterCallback = this.props.history.listen((location) => {
            this.setState({
                currentPath: location.pathname
            });
        });
    }
    componentWillUnmount() {
        if (this.listenUnregisterCallback) {
            this.listenUnregisterCallback();
        }
    }
    goBack(defaultHref) {
        const { view: leavingView } = this.props.findViewInfoByLocation(this.props.location);
        if (leavingView) {
            const { view: enteringView } = this.props.findViewInfoById(leavingView.prevId);
            if (enteringView) {
                this.props.history.replace(enteringView.routeData.match.url, { direction: 'back' });
            }
            else {
                defaultHref && this.props.history.replace(defaultHref, { direction: 'back' });
            }
        }
        else {
            defaultHref && this.props.history.replace(defaultHref, { direction: 'back' });
        }
    }
    getHistory() {
        return this.props.history;
    }
    getLocation() {
        return this.props.location;
    }
    navigate(path, direction) {
        this.props.history.push(path, { direction });
    }
    getViewManager() {
        return ViewManager;
    }
    render() {
        return (React.createElement(NavContext.Provider, { value: this.state }, this.props.children));
    }
}

class RouteManager extends React.Component {
    constructor(props) {
        super(props);
        this.listenUnregisterCallback = this.props.history.listen(this.historyChange.bind(this));
        this.state = {
            viewStacks: {},
            hideView: this.hideView.bind(this),
            setupIonRouter: this.setupIonRouter.bind(this),
            removeViewStack: this.removeViewStack.bind(this),
            renderChild: this.renderChild.bind(this),
            transitionView: this.transitionView.bind(this)
        };
    }
    hideView(viewId) {
        const viewStacks = Object.assign({}, this.state.viewStacks);
        const { view } = this.findViewInfoById(viewId, viewStacks);
        if (view) {
            view.show = false;
            view.key = generateUniqueId();
            this.setState({
                viewStacks
            });
        }
    }
    historyChange(location, action) {
        this.setActiveView(location, action);
    }
    findViewInfoByLocation(location, viewStacks) {
        let view;
        let match;
        let viewStack;
        const keys = Object.keys(viewStacks);
        keys.some(key => {
            const vs = viewStacks[key];
            return vs.views.some(x => {
                const matchProps = {
                    exact: x.routeData.childProps.exact,
                    path: x.routeData.childProps.path || x.routeData.childProps.from,
                    component: x.routeData.childProps.component
                };
                match = matchPath(location.pathname, matchProps);
                if (match) {
                    view = x;
                    viewStack = vs;
                    return true;
                }
                return false;
            });
        });
        const result = { view, viewStack, match };
        return result;
    }
    findViewInfoById(id, viewStacks) {
        let view;
        let viewStack;
        const keys = Object.keys(viewStacks);
        keys.some(key => {
            const vs = viewStacks[key];
            view = vs.views.find(x => x.id === id);
            if (view) {
                viewStack = vs;
                return true;
            }
            else {
                return false;
            }
        });
        return { view, viewStack };
    }
    setActiveView(location, action) {
        const viewStacks = Object.assign({}, this.state.viewStacks);
        const { view: enteringView, viewStack: enteringViewStack, match } = this.findViewInfoByLocation(location, viewStacks);
        let direction = location.state && location.state.direction;
        if (!enteringViewStack) {
            return;
        }
        const { view: leavingView } = this.findViewInfoById(this.activeViewId, viewStacks);
        if (leavingView && leavingView.routeData.match.url === location.pathname) {
            return;
        }
        if (enteringView) {
            /**
             * If the page is being pushed into the stack by another view,
             * record the view that originally directed to the new view for back button purposes.
             */
            if (!enteringView.show && action === 'PUSH') {
                enteringView.prevId = leavingView && leavingView.id;
            }
            enteringView.show = true;
            enteringView.mount = true;
            enteringView.routeData.match = match;
            enteringViewStack.activeId = enteringView.id;
            this.activeViewId = enteringView.id;
            if (leavingView) {
                this.prevViewId = leavingView.id;
                if (leavingView.routeData.match.params.tab === enteringView.routeData.match.params.tab) {
                    if (action === 'PUSH') {
                        direction = direction || 'forward';
                    }
                    else {
                        direction = direction || 'back';
                        leavingView.mount = false;
                    }
                }
                /**
                 * If the leaving view is a Redirect, take it out of the rendering phase.
                 */
                if (leavingView.element.type === Redirect) {
                    leavingView.mount = false;
                    leavingView.show = false;
                }
                if (leavingView.element.type === Route && leavingView.element.props.render) {
                    if (leavingView.element.props.render().type === Redirect) {
                        leavingView.mount = false;
                        leavingView.show = false;
                    }
                }
                else if (leavingView.element.type === Redirect) {
                    leavingView.mount = false;
                    leavingView.show = false;
                }
            }
            this.setState({
                viewStacks
            }, () => {
                const enteringEl = enteringView.ref && enteringView.ref.current ? enteringView.ref.current : undefined;
                const leavingEl = leavingView && leavingView.ref && leavingView.ref.current ? leavingView.ref.current : undefined;
                this.transitionView(enteringEl, leavingEl, enteringViewStack.routerOutlet, leavingEl && leavingEl.innerHTML !== '' ? direction : undefined); // Don't animate from an empty view
            });
        }
    }
    componentWillUnmount() {
        this.listenUnregisterCallback && this.listenUnregisterCallback();
    }
    setupIonRouter(id, children, routerOutlet) {
        const views = [];
        let activeId;
        const ionRouterOutlet = React.Children.only(children);
        React.Children.forEach(ionRouterOutlet.props.children, (child) => {
            views.push(createViewItem(child, this.props.history.location));
        });
        this.registerViewStack(id, activeId, views, routerOutlet, this.props.location);
        function createViewItem(child, location) {
            const viewId = generateUniqueId();
            const key = generateUniqueId();
            const element = child;
            const matchProps = {
                exact: child.props.exact,
                path: child.props.path || child.props.from,
                component: child.props.component
            };
            const match = matchPath(location.pathname, matchProps);
            const view = {
                id: viewId,
                key,
                routeData: {
                    match,
                    childProps: child.props
                },
                element,
                mount: true,
                show: !!match,
                ref: React.createRef()
            };
            if (!!match) {
                activeId = viewId;
            }
            return view;
        }
    }
    registerViewStack(stack, activeId, stackItems, routerOutlet, location) {
        this.setState((prevState) => {
            const prevViewStacks = Object.assign({}, prevState.viewStacks);
            prevViewStacks[stack] = {
                activeId: activeId,
                views: stackItems,
                routerOutlet
            };
            return {
                viewStacks: prevViewStacks
            };
        }, () => {
            const { view: activeView } = this.findViewInfoById(activeId, this.state.viewStacks);
            if (activeView) {
                this.prevViewId = this.activeViewId;
                this.activeViewId = activeView.id;
                const direction = location.state && location.state.direction;
                const { view: prevView } = this.findViewInfoById(this.prevViewId, this.state.viewStacks);
                this.transitionView(activeView.ref.current, prevView && prevView.ref.current || undefined, routerOutlet, direction);
            }
        });
    }
    ;
    removeViewStack(stack) {
        const viewStacks = Object.assign({}, this.state.viewStacks);
        delete viewStacks[stack];
        this.setState({
            viewStacks
        });
    }
    renderChild(item) {
        const component = React.cloneElement(item.element, {
            computedMatch: item.routeData.match
        });
        return component;
    }
    findActiveView(views) {
        let view;
        views.some(x => {
            const match = matchPath(this.props.location.pathname, x.routeData.childProps);
            if (match) {
                view = x;
                return true;
            }
            return false;
        });
        return view;
    }
    transitionView(enteringEl, leavingEl, ionRouterOuter, direction) {
        /**
         * Super hacky workaround to make sure ionRouterOutlet is available
         * since transitionView might be called before IonRouterOutlet is fully mounted
         */
        if (ionRouterOuter && ionRouterOuter.componentOnReady) {
            this.commitView(enteringEl, leavingEl, ionRouterOuter, direction);
        }
        else {
            setTimeout(() => {
                this.transitionView(enteringEl, leavingEl, ionRouterOuter, direction);
            }, 10);
        }
    }
    async commitView(enteringEl, leavingEl, ionRouterOuter, direction) {
        await ionRouterOuter.commit(enteringEl, leavingEl, {
            deepWait: true,
            duration: direction === undefined ? 0 : undefined,
            direction: direction,
            showGoBack: direction === 'forward',
            progressAnimation: false
        });
        if (leavingEl && (enteringEl !== leavingEl)) {
            /**
             *  add hidden attributes
            */
            leavingEl.classList.add('ion-page-hidden');
            leavingEl.setAttribute('aria-hidden', 'true');
        }
    }
    render() {
        return (React.createElement(RouteManagerContext.Provider, { value: this.state },
            React.createElement(NavManager, Object.assign({}, this.props, { findViewInfoById: (id) => this.findViewInfoById(id, this.state.viewStacks), findViewInfoByLocation: (location) => this.findViewInfoByLocation(location, this.state.viewStacks) }), this.props.children)));
    }
}
const RouteManagerWithRouter = withRouter(RouteManager);
RouteManagerWithRouter.displayName = 'RouteManager';
class IonReactRouter extends React.Component {
    render() {
        const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
        return (React.createElement(BrowserRouter, Object.assign({}, props),
            React.createElement(RouteManagerWithRouter, null, children)));
    }
}

export { IonReactRouter, ViewManager };
//# sourceMappingURL=index.esm.js.map
